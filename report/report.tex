\documentclass[12pt]{article}

\usepackage{geometry}
\geometry{a4paper, margin=1in}

\begin{document}

% Vertically and horizontally center the title page
\begin{titlepage}
    \centering
    \vspace*{\fill}

    {\Huge \textbf{Report on Quizzical} \par}    
    \vspace{1cm}
    {\Large Ivor Walker\par}      
    \vspace{1cm}
    
    \vspace*{\fill}
\end{titlepage}

You should write a short report (around 1000-1500 words) detailing the coding design of your solution. You should include the following sections:

\section{Overview}
Overview: a brief description of what has been achieved in the submission. This should include a list of which requirements have been met and to what extent. Clearly state which API you used in your solution.

This submission provides all functionality described in sections basic, intermediate and advanced. It is a Python application that shows questions and a list of multiple choices answers obtained via the Open Trivia Database API to the user in a curses-based command line interface. The user has 30 seconds to select an answer or to play a chip. These chips (50/50, extra time, ask the host) gives the user an advantage in answering the question. If the user's answer is correct, the application adds to their score based on the difficulty of the question. This continues until the user quits or answers three questions incorrectly, at which point the game ends and the user's final score is displayed alongside a leaderboard of the top 10 scores and statistics on how long the session lasted.

\section{Design}
Design: a brief discussion of any interpretation of requirements and any design decisions taken, including any decisions about how you organised your application into classes and methods. Focus on the reasons for your decisions rather than just providing a description of what you did.

game.py
leaderboard.py
main.py
question.py
questions.py
timer.py
view.py

main.py is the entry point of the application. It initialises the view and game, starts the main loop and handles keyboard interrupts and potential network exceptions. ConnectionErrors can be generated by instances of the Questions class when fetching questions from the API, but need to be handled in main.py to ensure the application closes properly.
To quit the application, the user presses Ctrl+C rather than a dedicated quit key, which raises a KeyboardInterrupt and starts the quit sequence. Users of console applications are used to pressing Ctrl+C to quit but may overlook an instruction to press a specific key to quit. For example, a common gripe with Vim is that Ctrl+C does not quit the application but requires inputting a quit command :q. This approach also sidesteps the need to escape the arbitrary quit key in any input (e.g if the user's username contains the quit key). 

The View class (view.py) renders the game state to the terminal and contains all direct interactions with curses. I chose to seperate the view from the rest of the program to ???. 
The constructor initialises the curses screen and sets curses-related configurations. Among other standard settings, I enable raw mode to stop special character combinations (e.g Ctrl+C) from sending signals to Python or curses (e.g close the curses window) when recieving input. 
Although my view supports character and line input, I primarily use character input to register special character combinations and to integrate with the timer as character input, unlike line input, can be interrupted at will (i.e when the timer expires). 
The view contains two methods that are the main ways of displaying information to the user: show\_multiple\_choice, which displays a question and multiple choice answers, and show\_message, which just displays a message. There are other bespoke methods that deal with displaying information not displayable by these methods, such as showing the welcome form and showing the leaderboard.

The Game class (game.py) handles the game state. 
The constructor initialises the questions, timer, and leaderboard and the reset method, called in the entry point, resets the game state and prompts the user for their username and bonus category. I seperated the reset method from the constructor because I designed the reset method to be the interruptable part of initialisation - an interrupted constructor would mean the game object would never be instantiated, meaning the game and view could never close properly, whereas an interrupted reset method would mean the user wants to stop initialising (e.g mistakenly opened the game) and the game should close immediately. 
The play\_round method is the method called by the main loop in main.py. It asks the user for a difficulty level, then asks the user a question of that difficulty level and times the user's answer. If the user answers correctly, the game adds to the user's score based on the difficulty level of the question. If the user answers incorrectly, the number of incorrect answers is incremented, and if the user answers three questions incorrectly the game ends.
Once the game ends, the user is asked if they want to restart the game. Regardless of whether the user wants to restart the game, the user's score is added to the leaderboard and the leaderboard is displayed. The user's score is also compared to the high score, and the user is shown a message if they have beaten the high score. If the user wants to restart the game, the game is reset, else the main loop is exited and the game immediately ends.
These interactions requiring the user to choose one option from many are handled by the ask\_multiple\_choice method, which asks the user a question (via view.show\_multiple\_choice), waits for the user to input an answer, checks if the user's answer is a valid option and returns the user's valid answer. The method that asks the user a trivia question (ask\_question) is a wrapper around ask\_multiple\_choice that also shows the user's current status and adds "play a chip" as an option to the multiple choice answers.
The play\_chip method handles the user playing a chip. It asks the user to choose one chip from a list of available chips, and calls the method of the appropriate chip. With the exception of the 'extra time' chip which calls a method of the Timer class, all chips call methods of the Question class.

The Question class (question.py) represents a single question.
The constructor takes in a JSON object from the API representing a question and stores the question's attributes. It unescapes HTML entities in the question and answers, combines the correct and incorrect answers into a single list of choices and shuffles it.
The other methods (fifty\_fifty, ask\_the\_host) modify the question in-place ???. I chose to modify the question in-place to simplify playing multiple chips on the same question. Since the question object is discarded after the user answers it, modifying the question in-place has no effect on future questions.

The Questions class (questions.py) represents a list of questions, and fetches questions from the API.
The constructor method fetches a new token from the API. I attach this token with any fetch request for more questions to ensure the API fetches unique questions. Once the token is obtained, the constructor fetches the first batch of questions and stores them in a list using the fetch\_new\_questions method.
The fetching method fetches the maximum number of questions (50) from the API and adds them to the list of questions. 

The leaderboard class (leaderboard.py) 
\section{Resources}
Resources: a brief description of what external technologies and resources you used during the development of your solution and what you used them for. This should include references to any external libraries, tutorials, forums, websites, books, etc. that you used to produce your solution.

\section{Evaluation}
Evaluation: a brief reflection on the success of your application. How did you test it? What went well and what could be improved? What might you do differently next time or if you had more time?

\end{document}

